# c++ 八股

___

## new 和 malloc 的区别

- new、delete是C++中独有的**操作符**，而malloc和free是C/C++中的**标准库函数**
- new创建对象在分配内存的时候**会自动调用构造函数，同时也可以完成对对象的初始化**，delete也能自动调用析构函数。因为malloc和 free是库函数而不是运算符，**不在编译器控制范围之内，所以不能够自动调用构造函数和析构函数**。也就是mallloc只是单纯地为变量分配内存，free也只是释放变量的内存
- new返回的是**指定类型的指针**，并且可以**自动计算所申请内存的大小**。而malloc返回的是**void*类型**，我们需要**强行将其转换为实际类型的指针**，并且需要**指定好要申请内存的大小**，malloc不会自动计算的
- new操作符从**自由存储区**上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存
- new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL

## malloc原理



## static 

在 C 语言中，static 作用：“改变生命周期” 或者 “改变作用域”。有以下特性：

- static 局部变量：局部变量为动态存储，即指令执行到定义处才分配内存。将一个局部变量声明为静态变量，使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中
- static 全局变量：全局变量即定义 {} 外面，其本身就是静态变量，编译时就分配内存。这只会**改变其连接方式**，使其只在本文件内部有效，而其他文件不可连接或引用该变量
- static函数：对函数的**连接方式产生影响**，使得函数只在本文件内部有效，对其他文件是不可见的（如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字 extern，表示该函数是外部函数，可供其他文件调用）

到了C++的时候，static多了几个其他的作用：

- static 类成员变量：表示这个成员为全类所共有，对类的所有对象只有一份拷贝，可以借助类名直接访问（需要在类外初始化）
- static 类成员函数：表示这个函数为全类所共有，而且只能访问静态成员变量，因为这个函数不接收 this 指针

## const

- const 常量：定义时就初始化，以后不能更改
- const 形参：`func(const int a) {} `，该形参在函数里不能改变
- const 修饰类成员变量：初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表
- const 修饰类成员函数：该函数对成员变量只能进行**只读**操作，就是const类成员函数是不能修改成员变量的数值的

## 指针和引用的关系

### 相同

- 都是地址的概念，指针所指内存地址，引用是某块内存的别名
- **两者都是占内存的**，程序为指针变量分配内存区域，在32位系统指针变量一般占用4字节内存。而引用本质是**指针常量**（`type * const pointer`），所指向的对象不能改变，但指向的对象的值可以改变。引用和指针一样是地址概念，所以本身都是会占用内存的（有的编译器优化后就不占用内存了）

### 不同

- 引用仅是个别名；指针是一个实体
- 指针和引用的自增(++)运算意义不一样。引用是对值的自增；指针是对内存地址的自增
- 引用使用时无需解引用(*)；指针需要解引用
- 引用只能在定义时被初始化一次，之后不可变；指针可变
- 引用不能为空；指针可以为空
- 没有引用常量；有指针常量
- “`sizeof` 引用”得到的是所指向的变量(对象)的大小；而“`sizeof` 指针”得到的是指针本身的大小，在32位系统指针变量一般占用4字节内存

### 转换

- 指针转引用：解引用后可以用在引用参数中
- 引用转指针：使用取地址符&

## 常量指针 指针常量 常量引用

### 常量指针

形如`const int *p` 或 `int const *p` 即**指向常量的指针**，指针所指地址的对象值不可更改（因为是常量），但指针本身的指向可以更改

### 指针常量

形如 `int * const p`  即指针本身是常量，指针所指地址的对象值可以更改，但指针本身的指向不可更改

### 常量引用

形如`const int &r = a`  即**指向常量的引用**，不可以通过 r 来改变 a 的值

### 没有引用常量

引用的本质是指针常量

## const 常量和 #define 的区别

- #define 定义的常量没有类型。#define 所定义的宏变量在**预处理阶段**的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换

  const 定义的常量有类型（多了**类型检查**）。存放在内存的静态区域中，在**编译时**确定其值。在程序运行过程中const变量**只有一个拷贝**，而 #define 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的**内存**要比 const 变量的大得多

- 用 #define 定义的常量是不可以用指针变量去指向的，用 const 定义的常量是可以用指针去指向该常量的地址的

- 用 #define 可以定义一些简单的函数（宏替换只作替换，不做计算，不做表达式求解），const 是不可以定义函数的

## 内存分配

- 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如**常量区（静态常量区），全局区（全局变量区）和静态变量区（静态区）**
- 在栈上创建。在执行函数时，函数内**局部变量和参数**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限
- 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块

## 变量的存储方式和生命周期

### 全局变量

在函数外定义的变量，且不加 static 、 const 修饰

- 作用域：全局作用域（全局变量只需在一个源文件中定义，就可以作用于所有的源文件）
- 生命周期：程序运行期一直存在
- 引用方法：其他文件中要使用必须用extern 关键字声明要引用的全局变量
- 内存分布：静态存储区

```c++
//defime.cpp  
int g_iValue = 1;  
//main.cpp  
extern int g_iValue;  
int main()  
{  
    cout << g_iValue;  
    return 0;  
}  
```

### 全局静态变量

在函数外定义的变量，使用 static 或 const 修饰

-  作用域：文件作用域（只在被定义的文件中可见）
- 生命周期：程序运行期一直存在
- 内存分布：静态存储区

```c++
const int iValue_1;  
static const int iValue_2;  
static int iValue_3;  
int main()  
{  
    return 0;  
} 
```

### 静态局部变量

局部作用域用中用static定义

- 作用域：局部作用域（只在局部作用域中可见）
- 生命周期：程序运行期一直存在
- 内存分布：静态存储区

```c++
void function()  
{  
    static int iREFCounter = 0;  
}
```

### 局部变量

- 作用域：局部作用域（只在局部作用域中可见）
- 生命周期：程序运行出局部作用域即被销毁
- 内存分布：栈区

## volatile

### 解析

volatile 的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用 volatile 声明变量值的时候，编译器对访问该变量的代码就不再进行优化，系统**总是重新从它所在的内存读取数据**，即使它前面的指令刚刚从该处读取过数据。

volatile 关键词的作用是影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错

### 场景

- 多任务环境下（如多线程）各任务间共享的标志应该加 volatile
- 断服务程序中修改的供其它程序检测的变量需要加 volatile

## inline

- 相当于把内联函数里面的内容写在调用内联函数处。相当于不用执行进入函数的步骤，直接执行函数体

### 优点

- 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收、结果返回等，从而**提高程序运行速度**

- 相当于宏，却比宏多了**类型检查**，真正具有函数特性

- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。因此内联函数可以访问类的成员变量，宏

  定义则不能

### 缺点

- 代码膨胀。消耗更多的内存空间
- 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器

> 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联

## extern "C"

- 被 extern 限定的函数或变量是 extern 类型的
- 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和链接的

`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题

## explicit

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外

explicit 关键字的作用就是防止类构造函数的隐式自动转换.。explicit 关键字只对有一个参数的类构造函数有效，如果类构造函数参数大于或等于两个时，是不会产生隐式转换的，所以 explicit 关键字也就无效了。但是, 也有一个例外，就是当除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效，此时，当调用构造函数时只传入一个参数，等效于只有一个参数的类构造函数

## 数组存放在哪里

### 固定数组

- 函数内：栈
- 全局数组或静态数组：静态存储区
- 类中：堆

### 动态数组

- 全部在堆中

## struct 和 class 的区别

C++ 中存在 struct 的唯一意义就是为了让 C 语言程序员有归属感，是为了让 C++ 编译器兼容以前用 C 语言开发的项目。两者最大区别是 struct 里面默认的访问控制是 public ，而 class 中的默认访问控制是 private。

## 类型转换机制

C 风格类型转换 `TypeName b = (TypeName)a`，C++ 也是支持 C 风格的强制转换,但是 C 风格的强制转换可能带来一些隐患,让一些问题难以察觉.所以 C++ 提供了一组可以用在不同场合的强制转换的函数

### static_cast

用于类层次结构中基类和派生类之间指针或引用的转换 （非多态类型转换）或**转换数值数据类型（如 float -> int）**

- 不执行运行时类型检查（转换安全性不如 dynamic_cast）
- 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）
- C++ 的任何的隐式转换都是使用 static_cast 来实现

> 向上转换是一种隐式转换

```c++
/* 常规的使用方法 */
float f_pi = 3.141592f
int   i_pi = static_cast<int>(f_pi); /// i_pi 的值为 3
/* class 的上下行转换 */
class Base{
    // something
};
class Sub: public Base{
    // something
}
// 上行 Sub -> Base
// 编译通过，安全
Sub sub;
Base *base_ptr = static_cast<Base*>(&sub);  
// 下行 Base -> Sub
// 编译通过，不安全
Base base;
Sub *sub_ptr = static_cast<Sub*>(&base);    
```

### const_cast

用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）

- 常量指针被转化成非常量的指针，并且仍然指向原来的对象
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象
- const_cast 一般用于修改指针。如 const char *p 形式

```c++
int main() {
    // 原始数组
    int ary[4] = { 1,2,3,4 };
    // 打印数据
    for (int i = 0; i < 4; i++)
        std::cout << ary[i] << "\t";
    std::cout << std::endl;
    // 常量化数组指针
    const int*c_ptr = ary;
    //c_ptr[1] = 233;   //error
    // 通过const_cast<Ty> 去常量
    int *ptr = const_cast<int*>(c_ptr);
    // 修改数据
    for (int i = 0; i < 4; i++)
        ptr[i] += 1;    //pass
    // 打印修改后的数据
    for (int i = 0; i < 4; i++)
        std::cout << ary[i] << "\t";
    std::cout << std::endl;
    return 0;
}
/*  out print
    1   2   3   4
    2   3   4   5
*/
```

### reinterpret_cast

处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释。但是仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换

- 指针之间的转换，引用之间的转换
- 指针和足够大的int型之间的转换，整数到指针的转换

```c++
int main() {
    int *ptr = new int(233);
    uint32_t ptr_addr = reinterpret_cast<uint32_t>(ptr);
    cout << "ptr 的地址: " << hex << ptr << endl
        << "ptr_addr 的值(hex): " << hex << ptr_addr << endl;
    delete ptr;
    return 0;
}
/*
ptr 的地址: 0061E6D8
ptr_addr 的值(hex): 0061e6d8
*/
```

### dynamic_cast

用于多态类型的转换

- 执行运行时类型检查
- 只适用于指针或引用
- 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
- 可以在整个类层次结构中移动指针，包括向上转换、向下转换

```c++
#include<iostream>
using namespace std;
class Base{
public:
    Base() {}
    ~Base() {}
    void print() {
        std::cout << "I'm Base" << endl;
    }
    virtual void i_am_virtual_foo() {}
};
class Sub: public Base{
public:
    Sub() {}
    ~Sub() {}
    void print() {
        std::cout << "I'm Sub" << endl;
    }
    virtual void i_am_virtual_foo() {}
};
int main() {
    cout << "Sub->Base" << endl;
    Sub * sub = new Sub();
    sub->print();
    Base* sub2base = dynamic_cast<Base*>(sub);
    if (sub2base != nullptr) {
        sub2base->print();
    }
    cout << "<sub->base> sub2base val is: " << sub2base << endl;
    cout << endl << "Base->Sub" << endl;
    Base *base = new Base();
    base->print();
    Sub  *base2sub = dynamic_cast<Sub*>(base);
    if (base2sub != nullptr) {
        base2sub->print();
    }
    cout <<"<base->sub> base2sub val is: "<< base2sub << endl;
    delete sub;
    delete base;
    return 0;
}
/* vs2017 输出为下
Sub->Base
I'm Sub
I'm Base
<sub->base> sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样

Base->Sub
I'm Base
<base->sub> base2sub val is: 00000000   // VS2017的C++编译器,对此类错误的转换赋值为nullptr
*/
```

## 智能指针

C++ 中经常需要 new 一个对象，开辟一个内存空间，返回一个指针来操作这个内存。使用完毕之后，需要通过 delete 来释放内存空间。如果内存没有释放，那这块内存将无法再利用，导致内存泄漏。为降低人为疏忽，C++ 11的新特性中引入了三种智能指针，来自动化地管理内存资源：

### unique_ptr

管理的资源唯一的属于一个对象，但是支持将资源移动给其他 unique_ptr 对象。当拥有所有权的 unique_ptr 对象析构时，资源即被释放。

### shared_ptr

管理的资源被多个对象共享，内部采用引用计数跟踪所有者的个数。当最后一个所有者被析构时，资源即被释放。

### weak_ptr

与 shared_ptr 配合使用，虽然能访问资源但却不享有资源的所有权，不影响资源的引用计数。有可能资源已被释放，但 weak_ptr 仍然存在。因此每次访问资源时都需要判断资源是否有效。

## 虚继承

因为 C++ 支持多重继承，那么在这种情况下会出现重复的基类这种情况，也就是说可能出现将一个类两次作为基类的可能性，此时出现了重复。为节省空间，可以使用虚继承。

> 虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在 C++ 中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间

> 不要全部都使用虚继承，因为虚继承会破坏继承体系，**不能按照平常的继承体系来进行类型转换**（如 C++ 提供的强制转换函数static_cast 对继承体系中的类对象转换一般可行的，这里就不行了）。所以不要轻易使用虚继承，更不要在虚继承的基础上进行类型转换，切记切记

## 子类如何调用父类的同名函数和父类成员变量

- 使用 using 关键字

- 使用 :: 域操作符

## 多态实现的基础和原理

### 基础

- 继承
- 虚函数重写
- 父类指针（引用）指向子类对象

### 原理

每一个有「虚函数」的类（或有虚函数的类的派生类）都有一个「虚函数表」，该类的任何对象中都放着**虚函数表的指针**。「虚函数表」中列出了该类的「虚函数」地址。

```c++
using namespace std;
class Father
{
public:
    void Face()
    {
        cout << "Father's face" << endl;
    }

    virtual void Say()
    {
        cout << "Father say hello" << endl;
    }
};
class Son:public Father
{
public:
    void Say()
    {
        cout << "Son say hello" << endl;
    }
};
void main()
{
    Son son;
    Father *pFather = &son; // 隐式类型转换
    pFather->Say();
}
```

编译器在**编译**的时候，发现 Father 类中有虚函数，此时编译器会为每个包含虚函数的**类**创建一个**虚表**（即 **vtable**），该表是一个一维数组，在这个数组中存放每个虚函数的地址，那么如何定位虚表呢？编译器另外还为每个**对象**提供了一个**虚表指针**（即 **vptr**），这个指针指向了对象所属类的虚表，在程序**运行**时，根据对象的类型去初始化 vptr，从而让 vptr 正确的指向了所属类的虚表，从而在调用虚函数的时候，能够找到正确的函数。对于第二段代码程序，由于 pFather 实际指向的对象类型是 Son，因此 vptr 指向的 Son 类的 vtable，当调用 pFather -> Son() 时，根据虚表中的函数地址找到的就是 Son 类的 Say() 函数.   

正是由于每个对象调用的虚函数都是通过虚表指针来索引的，也就决定了虚表指针的正确初始化是非常重要的，换句话说，在虚表指针没有正确初始化之前，我们不能够去调用虚函数，那么虚表指针是在什么时候，或者什么地方初始化呢？

答案是**在构造函数中进行虚表的创建和虚表指针的初始化**，在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否还有继承者，它初始化父类对象的虚表指针，该虚表指针指向父类的虚表，当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。

## 多态类的内存布局

如果类里有一个或多个虚函数，那么需要加1个虚指针空间，如果还是虚继承，那么需要再加1个虚指针空间，最多就2个虚指针空间

## 深浅拷贝

浅拷贝是增加了一个指针，指向原来已经存在的内存。浅拷贝在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误。

而深拷贝是增加了一个指针，并新开辟了一块空间让指针指向这块新开辟的空间。深拷贝和浅拷贝的不同之处，仅仅在于修改了下拷贝构造函数，以及赋值运算符的重载。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的

## 拷贝构造函数

默认拷贝构造函数执行的是浅拷贝，对于**凡是包含动态分配成员或包含指针成员**的类都应该提供拷贝构造函数。在提供拷贝构造函数的同时，还应该考虑重载"="赋值操作符号

## 调用拷贝构造函数的情况

- 一个对象以值传递的方式传入函数体
- 一个对象以值传递的方式从函数返回
- 一个对象需要通过另外一个对象进行初始化

## 虚析构函数

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不会调用子类析构函数，这样就会造成子类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。

## 构造函数为什么一般不定义为虚函数

- **从存储空间角度**：指向 vtable 的 vptr 指针存储在对象的内存空间的。如果此时构造函数是虚的，就须要通过 vtable 来调用，但是对象还没有实例化，也就是内存空间还没有 vtable， 无法寻找 vtable（vptr 在构造函数调用后才建立，因而构造函数不可能成为虚函数）
- **从使用角度**：虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义
- 构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数

## 纯虚函数

形如 `virtual int fun () = 0;` 纯虚函数的作用是在基类中为其派生类保留一个函数的名字，以便派生类根据需要对他进行定义。**含有纯虚函数的类是抽象类，抽象类无法实例化**。如果在一个类中声明了纯虚函数，在其派生类中没有对其函数进行定义，则该虚函数在派生类中仍然为纯虚函数，该派生类仍为抽象类。

## 静态绑定和动态绑定

### 静态类型

对象在声明时采用的类型，在编译期既已确定

### 动态类型

通常是指一个指针或引用目前所指对象的类型，是在运行期决定的

### 静态绑定

绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期

### 动态绑定

绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期

**非虚函数一般都是静态绑定，而虚函数都是动态绑定**（如此才可实现多态性）

只有**指定为虚函数的成员函数才能进行动态绑定**，且**必须通过基类类型的引用或指针进行函数调用**，因为每个派生类对象中都拥有基类部分，所以可以使用基类类型的指针或引用来引用派生类对象。而指针或引用是在运行期根据他们绑定的具体对象确定。

# C++ 常见编程题

---

## 实现简易 shared_ptr



## 实现简易 string 类

```c++
class String {
public:
    // 构造：默认（传参）、拷贝构造、移动构造
    String(const char *str = nullptr);
    String(const String &other);
    String(String &&other);

    // 析构
    ~String();

    // 赋值：拷贝赋值、移动赋值
    String &operator=(const String &other); 
    String &operator=(String &&other);

private:
    char *m_data;
};

String::String(const char *str)
{
    if (str == nullptr) {
        m_data = new char[1];
        *m_data = '\0';
        cout << "Default constructor" << endl;
    }
    else {
        int length = strlen(str);
        m_data = new char[length + 1];
        strcpy(m_data, str);
        cout << "Pass argument constructor" << endl;
    }
}

String::String(const String &other)
{
    int length = strlen(other.m_data);
    m_data = new char[length + 1];
    strcpy(m_data, other.m_data);
    cout << "Copy constructor" << endl;
}


String::String(String &&other)
{
    m_data = other.m_data;
    other.m_data = nullptr;
    cout << "Move constructor" << endl;
}

String::~String()
{
    delete[] m_data;
    cout << "Destructor" << endl;
}

String &String::operator=(const String &other)
{
    if (this != &other) {
        if (!m_data) delete[] m_data;
        int length = strlen(other.m_data);
        m_data = new char[length + 1];
        strcpy(m_data, other.m_data);
    }
    cout << "Copy assignment" << endl;
    return *this;
}

String &String::operator=(String &&other)
{
    if (this != &other) {
        delete[] m_data;
        m_data = other.m_data;
        other.m_data = nullptr;
    }
    cout << "Move assignment" << endl;
    return *this;
}
```

## ++、= 运算符重载

```c++

class point{
public:
	point(int a,int b):x(a),y(b){}
	
  // 前置运算符，需要引用返回，不需要参数。返回自增后的值，且返回的是一个左值
	point& operator++(){ // 返回引用 1、作为左值 2、允许进行连续赋值 3、的时候调用拷贝构造函数和析构函数导致不必要的开销，降低赋值运算符的效率
		x++;
		y++;
		return *this;
	}
  // 后置++，不需要引用返回，需要参数区分。返回自增前的值，且返回的是一个右值
	point operator++(int){ // 参数仅作为区分前置、后置用
		point temp(x,y); 
		x++;
		y++;
		//cout<<"x1 = "<<temp.x<<",y1 = "<<temp.y<<endl;
		
		return temp;
	}

	void show(){
		cout<<"x = "<<x<<",y = "<<y<<endl;
	}
private:
	int x;
	int y;
};
```

# 操作系统

---

## 进程管理

### 进程和线程

进程是**资源分配**的基本单位，线程是**资源调度**的基本单位。一个进程可以有多个线程，多个线程共享同个进程下的所有共享资源，每个线程有自己的**堆栈**和**局部变量**，

线程和进程最大的不同在于基本上**各进程是独立的**，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。**线程执行开销小，但不利于资源的管理和保护**；而进程正相反。

### 进程有哪几种状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

### 进程间的通信方式

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以**进程之间要通信必须通过内核**。

- **管道**：实际上**内核里面的一串缓存**，分为*匿名管道*和*命名管道*。匿名管道只能用于具有亲缘关系的进程之间的通信。命名管道克服了匿名管道的缺点，以磁盘文件的方式存在，可以实现本机任意两个进程通信，并且严格遵循**先进先出（FIFO）**。优点：简单，缺点：管道通信方式效率较低，不适合进程间频繁地交换数据。

  > Linux 中 `|` 就是管道通信
  >
  > ```shell
  > $ ps auxf | grep mysql
  > ```
  >
  > 它的功能是将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入，从这功能描述，可以看出**管道传输数据是单向的**，如果想相互通信，我们需要创建两个管道才行

- **消息队列**：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。优点：**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**，缺点：**不适合比较大数据的传输**，**存在用户态与内核态之间的数据拷贝开销**

- **共享内存**：**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**，使得**多个进程可以访问同一块内存空间**，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式**需要依靠某种同步操作**，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。

- **信号量：**为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制。**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**

- **信号：**信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

- **套接字（socket）：**主要用于在**客户端和服务器之间通过网络进行通信**。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点

### 进程调度算法

- **先到先服务**：从就绪队列中选择一个**最先进入该队列**的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度
- **短作业优先**：从就绪队列中选出一个估计**运行时间最短**的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度
- **时间片轮转调度算法**：每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换
- **多级反馈队列调度算法**：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法**既能使高优先级的作业得到响应又能使短作业（进程）迅速完成**，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法
- **优先级调度**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级

### 父进程与子进程

父进程与子进程拥有独立的地址空间和 PID 参数、不同的父进程号、自己的文件描述符。**共享代码段、数据段和用户堆栈内存空间是与子进程**。**只有当子进程在运行中出现写操作时**，才会产生中断，并为子进程分配内存空间。

### 线程同步的方式

- **互斥量**：采用互斥对象机制，**只有拥有互斥对象的线程才有访问公共资源的权限**。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制
- **信号量**：它**允许同一时刻多个线程访问同一资源**，但是需要控制同一时刻访问此资源的最大线程数量
- **事件**：Wait / Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### 同步、异步、互斥、阻塞、非阻塞

- **同步**：每个线程之间按预定的先后次序进行运行
- 同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的
- **互斥**：当有若干个线程访问同一块资源时，规定同一时间只有一个线程可以得到访问权，其它线程需要等占用资源者释放该资源才可以申请访问。**线程互斥可以看成是一种特殊的线程同步**

- 阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞

- **阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果**

### 多进程和多线程的优缺点

一个进程由PCB（进程控制块）、数据段、代码段组成，进程本身不可以运行程序，而是像一个容器一样，先创建出一个主线程，分配给主线程一定的系统资源，这时候就可以在主线程开始实现各种功能。当我们需要实现更复杂的功能时，可以在主线程里创建多个子线程，跟人多好干活的道理一样，多个线程在同一个进程里，利用这个进程所拥有的系统资源合作完成某些功能

|                            多进程                            |                            多线程                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 更健壮，一个进程死了不影响其他进程，子进程死了也不会影响到主进程 | 多线程比较脆弱，一个线程崩溃很可能影响到整个程序，因为多个线程是在一个进程里一起合作干活的 |
|              性能高，每个进程独立地址空间和资源              | 多个线程是一起共享了同个进程里的空间和资源，线程的性能上限一定比不上进程 |
|                          系统花销大                          |                          系统花销小                          |
|     多进程通讯因为需要跨越进程边界，不适合大量数据的传送     | 适合各线程间大量数据的传送，可以共享同一进程里的共享内存和变量 |
|       多进程逻辑控制比多线程复杂，需要与主进程做好交互       |              需要复杂的线程同步和加锁控制等机制              |

> **进程和线程的选择**：安全稳定选进程，快速频繁选线程

### 死锁

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成**两个线程都在等待对方释放锁**，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。

### 死锁的必要条件

- **互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
- **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
- **非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
- **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

### 解决死锁的方法

- **预防死锁**：只要破坏四个必要条件中的任何一个就能够预防死锁的发生

  - 破坏“占有并等待”：静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行
  - 破坏“循环等待”：层次分配

  > 预防死锁会导致 **低效的进程运行** 和 **资源使用率**

- **避免死锁**：银行家算法：当一个进程申请使用资源的时候，**银行家算法** 通过先 **试探** 分配给该进程资源，然后通过 **安全性算法** 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 **真的分配资源给该进程

  > 避免死锁也不利于各进程对系统资源的**充分共享**

- **死锁检测**：对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 **定时地运行一个 “死锁检测”** 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它

- **死锁解除**：当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来

## 内存管理

操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情

---

### 内存管理机制

简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理**和**段式管理**

- **块式管理** ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
- **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
- **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

> 页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求

### 页式管理

#### 快表

为了提高虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度

1. 使用快表之后的地址转换流程：
2. 根据虚拟地址中的页号查快表；
3. 如果该页在快表中，直接从快表中读取相应的物理地址；
4. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

#### 多级页表

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景

### 分页机制和分段机制的共同点和区别

1. 共同点：
   - 分页机制和分段机制都是为了提高内存利用率，减少内存碎片
   - 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的
2. 区别：
   - 页的大小是固定的，由操作系统决定。而段的大小不固定，取决于我们当前运行的程序
   - 分页仅仅是为了满足操作系统内存管理的需求。而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要

### 段页式管理

段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的

### 虚拟内存

**虚拟内存**可以让程序可以拥有超过系统物理内存大小的可用内存空间。**虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**。这样会更加有效地管理内存并减少出错。**拟内存的重要意义是它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间**

> **虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。

### 局部性原理

局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。局部性原理表现在以下两个方面：

1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作
2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的

### 虚拟内存的实现方式

- **请求分页存储管理** ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，**在作业开始运行之前，仅装入当前要执行的部分段即可运行**。假如在**作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存**，同时操作系统也可以将暂时不用的页面置换到外存中。
- **请求分段存储管理** ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
- **请求段页式存储管理**

> **分页存储和请求分页存储的区别**：请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。

### 页面置换算法

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来**选择淘汰哪一页的规则叫做页面置换算法**，我们可以把页面置换算法看成是淘汰页面的规则

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页

## Linux

### Linux 内核组成

主要有五个子系统组成：**进程调度、进程通信、内存管理、虚拟文件系统、网络接口**

### 内核态与用户态

- **内核态**：操作系统在内核态运行——运行操作系统程序
- **用户态**：应用程序只能在用户态运行——运行用户程序

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过 write、send 等**系统调用**，这些系统调用会调用内核的代码。进程会切换到 Ring0 ，然后进入 3G - 4G 中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到 Ring3 ，回到用户态。这样，用户态的程序就不能随意操作内核地址空间

### 内核抢占

如果进程正在执行内核函数时（即它在**内核态运行**时），允许发生内核切换（被替换的进程是正在执行内核函数的进程），这个内核就是抢占的

### 内核间同步

在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问

- **原子操作**
- **信号量（semaphore）**
- **顺序锁（seqlock）**
- 读写信号量（rw_semaphore）
- 自旋锁（spinlock）
- 大内核锁（BKL，Big Kernel Lock）
- 读写锁（rwlock）
- 大读者锁（brlock-Big Reader Lock） 
- 读-拷贝修改(RCU，Read-Copy Update)

### 用户与内核通信

- **系统调用**：用户空间进程通过系统调用进入内核空间，访问指定的内核空间数据
- **驱动程序**：用户空间进程可以使用封装后的系统调用接口访问驱动设备节点，以和运行在内核空间的驱动程序通信
- **共享内存（mmap）**：在代码中调用接口，实现内核空间与用户空间的地址映射

### 系统调用

为了**管理硬件资源和为应用程序开发人员提供良好的环境**来使应用程序具有更好的兼容性，为了达到这个目的，内核**提供一系列具备预定功能的多内核函数，通过一组称为系统调用（system call)的接口呈现给用户**。系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序

